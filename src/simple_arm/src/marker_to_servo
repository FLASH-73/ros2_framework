#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from visualization_msgs.msg import InteractiveMarkerFeedback
from geometry_msgs.msg import TwistStamped, PoseStamped
from tf2_ros import TransformListener, Buffer
from tf2_geometry_msgs import do_transform_pose
import tf2_ros
import math

class MarkerToServo(Node):
    def __init__(self):
        super().__init__('marker_to_servo')
        self.pub = self.create_publisher(TwistStamped, '/servo_node/delta_twist_cmds', 10)
        self.sub = self.create_subscription(
            InteractiveMarkerFeedback,
            '/rviz_moveit_motion_planning_display/robot_interaction_interactive_marker_topic/feedback',
            self.feedback_cb, 10
        )
        self.tf_buffer = Buffer()
        self.tf_listener = TransformListener(self.tf_buffer, self)
        self.planning_frame = 'base_link'
        self.last_pose = None
        self.get_logger().info('Marker to Servo bridge ready (twist delta mode)')

    def feedback_cb(self, msg):
        if msg.event_type != InteractiveMarkerFeedback.POSE_UPDATE:
            return

        current_pose = PoseStamped()
        current_pose.header = msg.header
        current_pose.pose = msg.pose

        # Transform to planning_frame if needed
        if msg.header.frame_id != self.planning_frame:
            try:
                transform = self.tf_buffer.lookup_transform(self.planning_frame, msg.header.frame_id, rclpy.time.Time())
                transformed_pose = do_transform_pose(current_pose.pose, transform)
                current_pose.pose = transformed_pose
                current_pose.header.frame_id = self.planning_frame
                current_pose.header.stamp = self.get_clock().now().to_msg()
            except tf2_ros.LookupException as e:
                self.get_logger().warn(f'TF error: {str(e)}')
                return

        if self.last_pose is None:
            self.last_pose = current_pose
            return

        # Linear delta (m/s, *50 for sensitivity)
        twist = TwistStamped()
        twist.header.stamp = self.get_clock().now().to_msg()
        twist.header.frame_id = self.planning_frame
        twist.twist.linear.x = (current_pose.pose.position.x - self.last_pose.pose.position.x) * 50.0
        twist.twist.linear.y = (current_pose.pose.position.y - self.last_pose.pose.position.y) * 50.0
        twist.twist.linear.z = (current_pose.pose.position.z - self.last_pose.pose.position.z) * 50.0

        # Angular delta (quaternion difference, small-angle approx)
        q1 = self.last_pose.pose.orientation
        q2 = current_pose.pose.orientation
        # Quaternion difference: q_diff = q2 * q1^-1
        q1_norm = math.sqrt(q1.w**2 + q1.x**2 + q1.y**2 + q1.z**2)
        q2_norm = math.sqrt(q2.w**2 + q2.x**2 + q2.y**2 + q2.z**2)
        if q1_norm > 0 and q2_norm > 0:
            q1 = [q1.x/q1_norm, q1.y/q1_norm, q1.z/q1_norm, q1.w/q1_norm]
            q2 = [q2.x/q2_norm, q2.y/q2_norm, q2.z/q2_norm, q2.w/q2_norm]
            # Inverse q1: (x, y, z, w) -> (-x, -y, -z, w)
            q1_inv = [-q1[0], -q1[1], -q1[2], q1[3]]
            # Quaternion multiply: q_diff = q2 * q1_inv
            w = q2[3]*q1_inv[3] - q2[0]*q1_inv[0] - q2[1]*q1_inv[1] - q2[2]*q1_inv[2]
            x = q2[3]*q1_inv[0] + q2[0]*q1_inv[3] + q2[1]*q1_inv[2] - q2[2]*q1_inv[1]
            y = q2[3]*q1_inv[1] - q2[0]*q1_inv[2] + q2[1]*q1_inv[3] + q2[2]*q1_inv[0]
            z = q2[3]*q1_inv[2] + q2[0]*q1_inv[1] - q2[1]*q1_inv[0] + q2[2]*q1_inv[3]
            # Small-angle approx: angular velocity ~ 2 * (x, y, z) / dt
            twist.twist.angular.x = 2.0 * x * 50.0
            twist.twist.angular.y = 2.0 * y * 50.0
            twist.twist.angular.z = 2.0 * z * 50.0

        self.pub.publish(twist)
        self.last_pose = current_pose
        self.get_logger().info(f'Published delta Twist: linear x={twist.twist.linear.x:.3f}, angular z={twist.twist.angular.z:.3f}')

def main(args=None):
    rclpy.init(args=args)
    node = MarkerToServo()
    rclpy.spin(node)
    rclpy.shutdown()

if __name__ == '__main__':
    main()